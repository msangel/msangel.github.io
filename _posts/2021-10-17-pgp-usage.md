---
title: Основы работы с GnuPG, часть 2. Использование.
date: 2021-07-10 09:41:00 Z
lang: ru
---
<!-- excerpt-start -->
В этой статье будут более практичные сценарии использования gpg. Предполагается, что у нас уже установлены набор утилит `gnupg2` и сгенерирована пара личных ключей. Если нет, то все можно сделать [быстро вот так](https://www.gnupg.org/documentation/manuals/gnupg-devel/Unattended-GPG-key-generation.html), только подставить свои данные<!-- excerpt-start -->:
<details>
<summary markdown='span'>команда</summary>

```bash
sudo apt install gnupg2
export GPG_TTY=$(tty)
gpg --batch --gen-key <<EOF
Key-Type: default
Key-Length: 4096
Subkey-Type: default
Subkey-Length: 4096
Name-Real: Artem Ivanov
Name-Email: wl07xo34yq@crepeau12.com
Expire-Date: 0
Passphrase: abc
EOF
```
</details>
Ну или прочитав [детальную статью об этом](https://k.co.ua/blog/2021/07/10/pgp-administration.html) и все настроив под свои потребности.

## Аргументы запуска
Типичный вызов утилиты выглядит так:
```bash
> gpg [опции] [входной файл]
```
Если входной файл опущен, на вход утилиты подается стандартный ввод.
Среди множества опций есть группа опций, отвечающих за режим работы:

* `-c`(`--symmetric`) - симметрическое шифрование паролем. Вниманию критиков и параноиков: паролем шифруется не само сообщение, а сеансовый ключ симметрического шифрования, которым уже защищается сообщение
* `-e`(`--encrypt`) - асимметрическое шифрование публичным ключем получателя. Режим совместим с `-c` и тогда сообщение можно будет расшифровать _одним из_ способов. Вместе с этой опцией чаще всего указывают:
  * `-r <recipient>` - получатель, чей ключ использовать
  * `-R <recipient>` - аналогичная команда с той разницей что это еще и имя самого получателя зашифрует
* `-d` - расшифровка. Логично что это не совместимо с режимами `-c` и `-e`.
* `-s`(`--sign`) - создание подписи приватным ключем, которую можно будет проверить публичным. Этот режим можно использовать как самостоятельно, так и в комбинации с любым из шифрований. В том случае подпись будет добавлена в зашифрованное сообщение и потому можно будет проверить владельца
* `--verify` - проверка подписи, если такая накладна на файл. Работает как самостоятельная команда, так и с режимом расшифровки.


Вообще опций очень много. Если вам нужно что-то сделать нестандартное, скорее всего для этого уже есть опция. Просто поверьте мне, ну или посмотрите на их [список](https://www.gnupg.org/documentation/manuals/gnupg/Option-Index.html#Option-Index). Тем не менее есть некоторые из них, которыми прийдется пользоваться чаще всего:
* `-a` - по умолчанию ответ утилиты таки бинарный, но эта опция переупакует его в текстовом представлении(ascii-armored). Есть еще отдельно команда для упаковывания файла в PGP ASCII armor: `gpg --enarmor < filename.bin > filename.txt` и соответственная обратная операция: `gpg --dearmor < filename.txt > filename.bin`
* `-o <outFileName>`(`--output`) - записывает вывод в указанный файл вместо стандартного вывода, по сути команда эквивалент перенаправлении стандартного вывода
* `--cipher-algo <algo>` - устанавливает алгоритм, который будет использован в данной команде. Список доступных можно узнать выполнив `gpg --version`. разные алгоритмы для разных задач. 
  * Симметричные: `IDEA`, `3DES`, `CAST5`, `BLOWFISH`, `AES`(он же `AES128`), `AES192`, `AES256`, `TWOFISH`, `CAMELLIA128`, `CAMELLIA192` и `CAMELLIA256`
  * С публичным ключем: `RSA`, `ELG`, `DSA`, `ECDH`, `ECDSA` и `EDDSA`
  * Хеширования: `SHA1`, `RIPEMD160`, `SHA256`, `SHA384`, `SHA512` и`SHA224`
  * Компрессии: `Uncompressed`, `ZIP`, `ZLIB` и `BZIP2`
* `--try-all-secrets` - если ты не знаешь чьим приватным ключем расшифровывать, оно переберет все наличные
* `--pinentry-mode loopback` - включает режим упрощенного ввода паролей с консоли. К использованию этого режима нужно относиться с пониманием, так как тут удобство повышается за счет безопасности. С [ответа](https://lists.gnupg.org/pipermail/gnupg-devel/2015-May/029847.html) в одной из рабочих групп по gpg: "loopback mode is a hack to bypass the standard way of asking for passphrases and to allow a simpler thing". Без этого ключа по умолчанию используется ввод пароля с помощью библиотеки [pinentry-curses](https://manpages.debian.org/testing/pinentry-curses/pinentry-curses.1.en.html), которая гарантирует что пароль нигде не будет сохранен. Дополнительные опции:
  * `--passphrase <password>` - ввод пароля как аргумент
  * `--passphrase-file <password-file>` - ввод файла с паролем как аргумент

## Что и зачем
Gpg позволяет шифровать файлы такими способами:
* ассиметричное - шифруется публичным ключом, расшифровывается приватным
* симметричное - шифруется и расшифровывается одной и той же парольной фразой

Gpg позволяет подписывать файлы, и соответственно верифицировать подпись на файлах. Еще шифрование можно совмещать с подписыванием файла. И еще зашифровать можно одним или более публичными ключами.

## Симметричное шифрование
Это шифрование, когда сообщение шифруется и расшифровывается одним и тем же паролем. 
Простейший пример шифрования сообщения, пароль будет запрошен в интерактивном режиме:
```bash
> echo "message" | gpg -c -a --cipher-algo AES
-----BEGIN PGP MESSAGE-----

jA0ECQMC+qVtCU87epf/0j0Bmp6SWatIOwGEUb5+u85P0ZzOjsMRjrxgqm8gnPhe
quv87PIs/iHsGpsGPOr1rY3LhnoYQO3ZjaBZdw/g
=DSZ/
-----END PGP MESSAGE-----
```
Для того чтоб задать пароль в виде аргументов, можно использовать `--pinentry-mode loopback` и тогда опции `--passphrase` и `--passphrase-file` будут работать:
```bash
> > echo "message" | gpg -c -a --pinentry-mode loopback --passphrase password
-----BEGIN PGP MESSAGE-----

jA0ECQMClRzymhTUUp7/0j0BYRI63DEYYjh8R45k2+U0GJBh5Wr8BiKYUFAPxfHx
t+zqHuTMSE2AtJ3/zBL4+q7vE5dnBGoGvFMhjNIZ
=KE8q
-----END PGP MESSAGE-----
```
#### Расшифровка
Для расшифровки сообщений выше можно воспользоваться этими командами:
```bash
read -r -d '' mess <<-EOF
-----BEGIN PGP MESSAGE-----

jA0ECQMClRzymhTUUp7/0j0BYRI63DEYYjh8R45k2+U0GJBh5Wr8BiKYUFAPxfHx
t+zqHuTMSE2AtJ3/zBL4+q7vE5dnBGoGvFMhjNIZ
=KE8q
-----END PGP MESSAGE-----
EOF
> echo "$mess" | gpg -d --pinentry-mode loopback --passphrase password
```
Вообще, данные можно подать на вход разными способами, например(пароль `123`):
```bash
cat  <<DATA | gpg --decrypt
-----BEGIN PGP MESSAGE-----

jA0ECQMCeqYI5XWTG0f/0sALAXTTjLlpuZXLHZRtIKMwEN9XNKPkemq/yv91fCGP
LRnZIGzyJKZ1G+xRKbFxrhbqo3laW4p29DOcTgQmBAr3+0OtMk1+vhDUJcEo675O
nBUY4Z8nitI2+wzG6L/JWL1/NtVCGa6pFiWqgyBzAu2bCINMmoS24/bxGuANq1XW
KKq2YMx/oFA+6EWqih+XT5R3vocBMD2OX6HM4zKvaCEvsuwz2vziza13nQK4T6MY
7/rsxsEhJr+NgMV5YepLhNscwjkv5scpAsqYjI4=
=cCk/

-----END PGP MESSAGE-----
DATA
```

Еще вариант: подать их на вход в виде файла
```bash
# файл в бинарном представлении
gpg --decrypt doc.gpg
# если не работает потому что файл в текстовом представлении, 
# можно сначала конвертировать текст в бинарные данные назад
gpg --dearmor -o- doc.gpg | gpg --decrypt
# где -o- это -o -, т.е. вывод в stdout ("--output -" тоже работает)
```

#### Идентифицировать алгоритм
На самом деле ты не всегда знаешь какой алгоритм использовался. Но в самом сообщение об этом [пишут](https://superuser.com/questions/1538456/how-to-find-out-symmetric-encryption-algorithm-used-in-pgp-encryption-with-gpg) и можно узнать не зная пароля(и не введя его, просто нажать "Cancel"):
```bash
> gpg -vv --show-session-key --list-packets encrypted_file.asc
.......
gpg: AES256 encrypted data
.......
```
или так:
```bash
> gpg --list-only -d encrypted_file.asc
gpg: AES256 encrypted data
gpg: encrypted with 1 passphrase
```

## Асимметричное шифрование
Это шифрование, когда сообщение шифруется публичным ключем получателя и расшифровать его может только получатель своим приватным ключем.
Для эксперимента например скачаем и установим мой публичный ключ: 
```bash
> curl -sSL https://k.co.ua/pubkey.pgp | gpg --import -
```

## Подписывание

Для подписи файла используется приватный ключ. Так как приватный (секретный) ключ хранится (очевидно же) в секрете владельцем, то исходя из предположения, что никто кроме владельца не имеет доступ к приватному ключу, мы можем быть уверены, что файл, который подписан этим приватным ключом, исходит от этого определённого лица. Если файл как либо после подписи был изменён, то эта подпись перестаёт быть верной (валидной) для данного файла. Поэтому, проверка подписи позволяет гарантировать:
* файл исходит от того лица, которое её подписало
* файл не был как либо модифицирован с момента подписи

Для проверки подписи определённого лица у вас должен быть публичный ключ этого лица.

Соединение подписанной версии файла вместе с ключем в бинарном формате:
```bash
> gpg --sign speech.txt
# создаст speech.txt.gpg
```
Соединение подписи внутри файла в изначальном(чаще всего текстовом) формате:
```bash
> gpg --clear-sign speech.txt
# создаст speech.txt.asc
> cat speech.txt.asc 
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA512

This is sample text I going to proove it is mine using signing.
-----BEGIN PGP SIGNATURE-----

iQEzBAEBCgAdFiEEULZwqN4fPNiVg4lSQcuY8zsGFG4FAmF0s4gACgkQQcuY8zsG
FG6pyAgAiIVG3Am3QIxrBgwYDlB44QyRr4yh62C6BcbqTZdG0ljzK8HyKs4qTFZz
Il67UpLfPvziI35WNcJMaoZwdVUT9BpRPGZTSH3yIk9KNHjEz2oh99PUwXBNGYMq
iXr+W2XL+ZjXk4fsk9DzADrFGR7NbQHz+1wyWNOJmtLN4LwDMk4o4RvuiSpwQdw0
SHDpefczD5rkC2Z0cD+BL6imHSa8pER4o79qOPiujxuKCtbJZGZf2qTMNJNV8l6S
PpDUoE7ycmlpmkOi1JnSBO/NfFiV2kA9FIhn4Tk9hyjEE8WWWQxEK2msKCDuKl5m
sS141HaDk7LmODcz8MzmpbEdpthXUQ==
=x2TL
-----END PGP SIGNATURE-----
```

Создание подписи для файла в виде отдельного файла подписи параметром `-b` (`--detach-sign`):
```bash
> gpg --sign -b speech.txt
# создаст speech.txt.sig
```
Этот вариант создания подписи [используется чаще всего](https://serverfault.com/questions/896228/how-to-verify-a-file-using-an-asc-signature-file), так как большинству пользователей не интересна эта электронная подпись и они не хотят извлекать оригинальный файл из закодированного сообщения. Потому подпись и оригинальный файл разделены. Ну а если кто-то задастся целью проверить подпись, то это все еще будет доступно.

#### Проверить подпись

Если файл и подпись в одном файле, то проверить подпись можно так:
```bash
> gpg --verify speech.txt.asc
gpg: Signature made нд, 24-жов-2021 04:21:29 +0300 EEST
gpg:                using RSA key 50B670A8DE1F3CD89583895241CB98F33B06146E
gpg: Good signature from "Vasyl Khrystiuk <h6.msangel@gmail.com>" [ultimate]
```
Если файл и подпись в отдельных файлах, то так:
```bash
> gpg --verify speech.txt.sig speech.txt
gpg: Signature made нд, 24-жов-2021 04:21:29 +0300 EEST
gpg:                using RSA key 50B670A8DE1F3CD89583895241CB98F33B06146E
gpg: Good signature from "Vasyl Khrystiuk <h6.msangel@gmail.com>" [ultimate]
```
Извлечь оригинальный файл из подписанного все той же командой decode `-d` (`-o` используется чтоб не смешивать вывод верификации и контент файла):
```bash
> gpg -d -o original_speech.txt speech.txt.gpg
gpg: Signature made нд, 24-жов-2021 04:40:22 +0300 EEST
gpg:                using RSA key 50B670A8DE1F3CD89583895241CB98F33B06146E
gpg: Good signature from "Vasyl Khrystiuk <h6.msangel@gmail.com>" [ultimate]
# будет воссоздан original_speech.txt из зашифрованного файла
```

#### Доверие публичному ключу
С одной стороны, система публичных ключей гарантирует, что прочитать защищенное сообщение сможет только человек, который его сгенерировал публичный ключ вместе с соответствующим ему приватный. С другой стороны, вообще нет никакой гарантии, что тот ключ, который вы нашли в интернете, сгенерировал именно тот человек, чье имя на нем написано. Ничто не мешает мне назваться именем [Линуса Торвальдса](https://github.com/torvalds) и отправить такой ключ на публичный сервер. Именно для того существует система доверия к публичным ключам. Работает она кстати довольно просто. У каждого локального публичного ключа есть [один из соответственных ему уровней доверия](https://www.gnupg.org/gph/en/manual/x334.html):
* unknown
* none
* marginal
* full
* ultimate

Уровни доверия каждый пользователь определяет для себя. Можно как вручную установить этот атрибут ключа локально, так и подписать этот ключ своим, что сделает ключ доверенным для себя, а в случае публикации такого измененного ключа даст всем знать, что вот лично вы этому ключу доверяете. И потому люди, которые доверяют вам, частично(marginal) тоже будут доверять этому ключу. Такая вот незадачливая реализация сети доверия.
Установка уровня доверия вручную:
```bash
gpg --edit-key 39499BDB
> trust
 (5 = ultimate trust)
> save 
```


## Хорошие, годные советы
1. Создаем основной ключ без срока годности, храним в сейфе и используем только для подписи(сертификации) других ключей. Экспортировать только приватные субключи можно опцией при экспорте `--export-secretsubkeys`
2. Ключи подписи и шифрования имеет смысл делать ограниченными во времени. В случае компрометации у вражеской стороны будет меньше времени ими воспользоваться.
3. Всюду можно пихать fingerprint своего публичного ключа. Кто знает - найдет и сможет безопасно писать вам сообщения.
4. Можно опубликовать публичный ключ в DNS. Есть много техник(RFC 2538, RFC 4398, RFC 7929) и [примеров](https://www.gushi.org/make-dns-cert/howto.html) и даже есть опции автоматического считывания такого ключа с домена.
5. Пароль можно сгенерировать стандартными средствами: `gpg --gen-random 1 16 | gpg --enarmor | sed -n 4p`
6. Так как на вход можно подавать что угодно, значит можно шифровать и архивы: `tar -cf - these files here | gpg -c > these-files-here.tgp`. Обратная операция: `gpg < these-files-here.tgp  | tar -xvf -`


## Используемые материалы:
* [https://www.gnupg.org/documentation/manpage.html](https://www.gnupg.org/documentation/manpage.html)
* [https://www.gnupg.org/gph/en/manual/x334.html](https://www.gnupg.org/gph/en/manual/x334.html)
* [https://www.gnupg.org/documentation/manuals/gnupg/GPG-Esoteric-Options.html](https://www.gnupg.org/documentation/manuals/gnupg/GPG-Esoteric-Options.html#index-no_002dsymkey_002dcache)
* [https://hackware.ru/?p=8215](https://hackware.ru/?p=8215)
* [https://gock.net/blog/2020/gpg-cheat-sheet/](https://gock.net/blog/2020/gpg-cheat-sheet/)







